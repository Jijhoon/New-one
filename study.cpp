#include <iostream>
#include <cmath>
int main()
{

    return 0;
}

/*
    int x = -5;
    //int abs(int x); -> absolute value of x

    std::cout << abs(x) << std::endl; // this state is working.

    std::cin >> x;
    std::cout << abs(x) << std::endl; // this state is working.
*/

/*
    int x = 5;
    int y = 2;

    //int pow(int x, int y); -> x raised to the power y

    std::cout << pow(x, y) << std::endl; // this state is working.

    std::cin >> x >> y;
    std::cout << pow(x, y) << std::endl; // this state is working.
*/

/*
    type cos(type x);                // cos(x) = cosine of x
    type sin(type x);                // sin(x) = sine of x
    type tan(type x);                // tan(x) = tangent of x
    type acos(type x);               // acos(x) = arc cosine of x
    type asin(type x);               // asin(x) = arc sine of x
    type atan(type x);               // atan(x) = arc tangent of x
    type atan2(type y, type x);      // atan2(y,x) = arc tangent of y/x
    type cosh(type x);               // cosh(x) = hyperbolic cosine of x
    type sinh(type x);               // sinh(x) = hyperbolic sine of x
    type tanh(type x);               // tanh(x) = hyperbolic tangent of x
    type exp(type x);                // exp(x) = ex
    type log(type x);                // log(x) = natural logarithm of x
    type log10(type x);              // log10(x) = base 10 logarithm of x
    type pow(type x, type y);        // pow(x,y) = x raised to the power y
    type sqrt(type x);               // sqrt(x) = square root of x
    type ceil(type x);               // ceil(x) = x rounded up
    type abs(type x);                // abs(x) = absolute value of x
    type floor(type x);              // floor(x) = x rounded down
    type fmod(type x, type y);       // fmod(x,y) = remainder of x/y
    type ldexp(type x, int exp);     // ldexp(x,exp) = x*(2exp)
    type frexp(type x, int *exp);    // frexp(x,exp) = x = y*(2exp)
    type modf(type x, type * ipart); // modf(x,ipart) = x = *ipart + y
    type erf(type x);                // erf(x) = error function of x
    type erfc(type x);               // erfc(x) = 1 - erf(x)
    type hypot(type x, type y);      // hypot(x,y) = sqrt(x2+y2)
    type j0(type x);                 // j0(x) = Bessel function of the first kind, order zero  // Bessel function : 베셀 함수 =  상미분 방정식을 통해 기술되는 해를 구하는 함수.
    type j1(type x);                 // j1(x) = Bessel function of the first kind, order one
    type jn(int n, type x);          // jn(n,x) = Bessel function of the first kind, order n
    type y0(type x);                 // y0(x) = Bessel function of the second kind, order zero
    type y1(type x);                 // y1(x) = Bessel function of the second kind, order one
    type yn(int n, type x);          // yn(n,x) = Bessel function of the second kind, order n
    type erf(type x);                // erf(x) = error function of x
    type erfc(type x);               // erfc(x) = 1 - erf(x)
    type gamma(type x);              // gamma(x) = gamma function of x
    type lgamma(type x);             // lgamma(x) = log(gamma(x))
*/